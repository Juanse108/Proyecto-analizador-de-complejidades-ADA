?start: program
program: stmt_list

?stmt_list: (stmt)*

?stmt: assign
     | for_loop
     | while_loop
     | repeat_loop
     | if_stmt
     | call_stmt
     // ‚¨ÖÔ∏è OJO: ya NO permitimos `| block` aqu√≠

block: BEGIN stmt_list END
block_or_list: block | stmt_list   // ‚¨ÖÔ∏è √∫nica definici√≥n (no dupliques esta regla)

assign: lvalue ASSIGN expr
lvalue: NAME ("[" subscript_list "]")* ("." NAME ("[" subscript_list "]")* )*

slice: expr (".." expr)?   // A[i] o A[1..j]
subscript_list: slice ("," slice)*   // M[i,j] o T[i, j, k]


for_loop: FOR NAME ASSIGN expr TO expr (STEP expr)? DO block_or_list END_FOR
while_loop: WHILE "(" bool_expr ")" DO block_or_list END_WHILE
repeat_loop: REPEAT block_or_list UNTIL "(" bool_expr ")"

if_stmt: IF "(" bool_expr ")" THEN block_or_list (ELSE block_or_list)? END_IF

call_stmt: CALL NAME "(" arg_list? ")"
arg_list: expr ("," expr)*

?bool_expr: or_expr
?or_expr: and_expr (OR and_expr)*
?and_expr: not_expr (AND not_expr)*
?not_expr: NOT not_expr
         | rel_expr
         | "(" bool_expr ")"      // ‚¨ÖÔ∏è permite ((...)) en condiciones booleanas

?rel_expr: expr (rel_op expr)?

rel_op: EQ | NE | NE2 | LT | LE | GT | GE | LE_U | GE_U | NE_U

?expr: sum
?sum: prod ((PLUS|MINUS) prod)*
?prod: unary ((MUL|REAL_DIV|DIV_INT|MOD) unary)*
?unary: MINUS unary -> neg
      | atom

?atom: NUMBER
     | T          -> true
     | F          -> false
     | NULL
     | lvalue
     | NAME "(" arg_list? ")"   -> func_call   // p.ej., length(A), ceil(x), floor(x)
     | CEIL_OPEN expr CEIL_CLOSE  -> ceil_brackets
     | FLOOR_OPEN expr FLOOR_CLOSE -> floor_brackets
     | "(" expr ")"

// ===== Palabras clave / cierres (prioridad alta) =====
ASSIGN.50: "<-" | "ü°®"

FOR.50: "for"
TO.50: "to"
STEP.50: "step"
DO.50: "do"
END_FOR.100: "end-for"

WHILE.50: "while"
END_WHILE.100: "end-while"

REPEAT.50: "repeat"
UNTIL.50: "until"

IF.50: "if"
THEN.50: "then"
ELSE.50: "else"
END_IF.100: "end-if"

BEGIN.60: "begin"
END.60: "end"

CALL.50: "CALL"
NULL.50: "NULL"

AND.50: "and"
OR.50: "or"
NOT.50: "not"
T.50: "T"
F.50: "F"

// Operadores aritm√©ticos
PLUS: "+"
MINUS: "-"
MUL: "*"
REAL_DIV: "/"
DIV_INT.50: "div"
MOD.50: "mod"

// Techo/Piso como brackets (opcionales)
CEIL_OPEN: "‚åà"
CEIL_CLOSE: "‚åâ"
FLOOR_OPEN: "‚åä"
FLOOR_CLOSE: "‚åã"

// Comparadores (ASCII + Unicode + <>)
EQ: "="
NE: "!="
NE2: "<>"
LE: "<="
LT: "<"
GE: ">="
GT: ">"
LE_U: "‚â§"
GE_U: "‚â•"
NE_U: "‚â†"

// Identificadores y literales
NAME: /[a-zA-Z_][a-zA-Z0-9_]*/
NUMBER: /[0-9]+/

%import common.WS_INLINE
%import common.NEWLINE
%ignore WS_INLINE
%ignore NEWLINE

// Comentarios: s√≥lo '‚ñ∫...'
COMMENT_ARROW: /‚ñ∫[^\n]*/
%ignore COMMENT_ARROW
