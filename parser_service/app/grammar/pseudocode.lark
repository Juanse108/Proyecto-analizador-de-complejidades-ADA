// ============================================================================
// pseudocode.lark ‚Äî Gram√°tica del pseudoc√≥digo para el microservicio
// ============================================================================
//
// Define la estructura sint√°ctica del pseudoc√≥digo que ser√° analizado
// por Lark y transformado en un √Årbol de Sintaxis Abstracta (AST).
//
// Convenciones principales:
// - Palabras clave en min√∫sculas (if, for, while, etc.).
// - Bloques expl√≠citos con begin/end o equivalentes.
// - Asignaciones con "<-" o "ü°®".
// - Permite comparadores Unicode (‚â§, ‚â•, ‚â†).
//
// Estructura general:
//   program ‚Üí lista de procedimientos o sentencias.
//   stmt    ‚Üí sentencia (asignaci√≥n, bucle, condicional, etc.).
// ============================================================================

?start: program
program: (proc_def | stmt)*

// ---------------------------------------------------------------------------
// SENTENCIAS PRINCIPALES
// ---------------------------------------------------------------------------
// Nota: no se permiten bloques o procedimientos dentro de stmt (solo top-level)
?stmt: assign
     | for_loop
     | while_loop
     | repeat_loop
     | if_stmt
     | call_stmt

// ---------------------------------------------------------------------------
// BLOQUES Y LISTAS
// ---------------------------------------------------------------------------
block: BEGIN stmt_list END
stmt_list: (stmt)*                // Secuencia expl√≠cita de sentencias
block_or_list: block | stmt_list  // Permite ambas formas (p.ej., DO ... END o sin BEGIN)

// ---------------------------------------------------------------------------
// PROCEDIMIENTOS (solo nivel superior)
// ---------------------------------------------------------------------------
proc_def: NAME "(" param_list? ")" BEGIN stmt_list END
param_list: NAME ("," NAME)*

// ---------------------------------------------------------------------------
// ASIGNACIONES Y LVALUES
// ---------------------------------------------------------------------------
assign: lvalue ASSIGN expr
lvalue: NAME ("[" subscript_list "]")* ("." NAME ("[" subscript_list "]")* )*
slice: expr (".." expr)?
subscript_list: slice ("," slice)*

// ---------------------------------------------------------------------------
// BUCLES Y CONDICIONALES
// ---------------------------------------------------------------------------
for_loop: FOR NAME ASSIGN expr TO expr (STEP expr)? DO block_or_list END_FOR
while_loop: WHILE "(" bool_expr ")" DO block_or_list END_WHILE
repeat_loop: REPEAT block_or_list UNTIL "(" bool_expr ")"

if_stmt: IF "(" bool_expr ")" THEN block_or_list (ELSE block_or_list)? END_IF

// ---------------------------------------------------------------------------
// LLAMADAS A PROCEDIMIENTOS O FUNCIONES
// ---------------------------------------------------------------------------
call_stmt: CALL NAME "(" arg_list? ")"
arg_list: expr ("," expr)*

// ---------------------------------------------------------------------------
// EXPRESIONES BOOLEANAS Y RELACIONALES
// ---------------------------------------------------------------------------
?bool_expr: or_expr
?or_expr: and_expr (OR and_expr)*
?and_expr: not_expr (AND not_expr)*
?not_expr: NOT not_expr
         | rel_expr
         | "(" bool_expr ")"

?rel_expr: expr (rel_op expr)?
rel_op: EQ | NE | NE2 | LT | LE | GT | GE | LE_U | GE_U | NE_U

// ---------------------------------------------------------------------------
// EXPRESIONES ARITM√âTICAS
// ---------------------------------------------------------------------------
?expr: sum
?sum: prod ((PLUS|MINUS) prod)*
?prod: unary ((MUL|REAL_DIV|DIV_INT|MOD) unary)*
?unary: MINUS unary -> neg
      | atom

// ---------------------------------------------------------------------------
// √ÅTOMOS Y FUNCIONES
// ---------------------------------------------------------------------------
?atom: NUMBER
     | T          -> true
     | F          -> false
     | NULL
     | lvalue
     | NAME "(" arg_list? ")"   -> func_call
     | CEIL_OPEN expr CEIL_CLOSE  -> ceil_brackets
     | FLOOR_OPEN expr FLOOR_CLOSE -> floor_brackets
     | "(" expr ")"

// ---------------------------------------------------------------------------
// PALABRAS CLAVE
// ---------------------------------------------------------------------------
ASSIGN.50: "<-" | "ü°®"
FOR.50: "for"
TO.50: "to"
STEP.50: "step"
DO.50: "do"
END_FOR.100: "end-for"
WHILE.50: "while"
END_WHILE.100: "end-while"
REPEAT.50: "repeat"
UNTIL.50: "until"
IF.50: "if"
THEN.50: "then"
ELSE.50: "else"
END_IF.100: "end-if"
BEGIN.60: "begin"
END.60: "end"
CALL.50: "CALL"
NULL.50: "NULL"
AND.50: "and"
OR.50: "or"
NOT.50: "not"
T.50: "T"
F.50: "F"

// ---------------------------------------------------------------------------
// OPERADORES ARITM√âTICOS
// ---------------------------------------------------------------------------
PLUS: "+"
MINUS: "-"
MUL: "*"
REAL_DIV: "/"
DIV_INT.50: "div"
MOD.50: "mod"

// ---------------------------------------------------------------------------
// OPERADORES ESPECIALES (TECHO/PISO UNICODE)
// ---------------------------------------------------------------------------
CEIL_OPEN: "‚åà"
CEIL_CLOSE: "‚åâ"
FLOOR_OPEN: "‚åä"
FLOOR_CLOSE: "‚åã"

// ---------------------------------------------------------------------------
// COMPARADORES
// ---------------------------------------------------------------------------
EQ: "="
NE: "!="
NE2: "<>"
LE: "<="
LT: "<"
GE: ">="
GT: ">"
LE_U: "‚â§"
GE_U: "‚â•"
NE_U: "‚â†"

// ---------------------------------------------------------------------------
// TOKENS BASE
// ---------------------------------------------------------------------------
NAME: /[a-zA-Z_][a-zA-Z0-9_]*/
NUMBER: /[0-9]+/

%import common.WS_INLINE
%import common.NEWLINE
%ignore WS_INLINE
%ignore NEWLINE

// ---------------------------------------------------------------------------
// COMENTARIOS
// ---------------------------------------------------------------------------
// Permite comentarios de una l√≠nea iniciados con ‚ñ∫
COMMENT_ARROW: /‚ñ∫[^\n]*/
%ignore COMMENT_ARROW
