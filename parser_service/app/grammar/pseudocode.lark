// ============================================================================
// pseudocode.lark ‚Äî Gram√°tica del pseudoc√≥digo (estilo Pascal simplificado)
// ---------------------------------------------------------------------------
// Objetivo:
//   - Representar el pseudoc√≥digo del enunciado con una sintaxis formal
//     adecuada para construir un AST y pasar una fase sem√°ntica posterior.
//
// Principales decisiones de dise√±o:
//   1. Una sentencia por l√≠nea: el separador de sentencias es SEP = salto(s) de l√≠nea.
//   2. Cuerpos de FOR/WHILE/IF delimitados por "begin ... end".
//      No existen variantes "end-if", "end-while" ni "end-for".
//   3. El bucle REPEAT usa la forma REPEAT ... UNTIL(cond) sin "begin/end".
//   4. Asignaci√≥n escrita como "<-" o "ü°®".
//   5. Comentarios de l√≠nea comienzan con el s√≠mbolo Unicode "‚ñ∫" y se ignoran.
//   6. El toplevel del programa s√≥lo admite:
//        - definici√≥n de clases,
//        - definici√≥n de procedimientos,
//        - un bloque libre (begin ... end).
//      No se permiten sentencias sueltas al nivel superior.
//   7. Palabras clave: se definen como tokens case-insensitive
//      para aceptar, por ejemplo, "Begin", "BEGIN" o "begin".
// ============================================================================

?start: program    // S√≠mbolo inicial que envuelve todo el programa

// ---------------------------------------------------------------------------
// 1. Estructura de programa y unidades de nivel superior
// ---------------------------------------------------------------------------

program: top_unit (SEP top_unit)* SEP?   // Secuencia de unidades top-level separadas por saltos de l√≠nea opcionales
top_unit: class_def                      // Definici√≥n de clase
        | proc_def                       // Definici√≥n de procedimiento
        | block                          // Bloque libre (begin ... end) usado como "programa principal"

// ---------------------------------------------------------------------------
// 2. Sentencias
// ---------------------------------------------------------------------------

// Cualquier sentencia que pueda aparecer dentro de un bloque
?stmt: assign        // Asignaciones
     | decl_stmt     // Declaraciones de objetos
     | for_loop      // Bucle FOR
     | while_loop    // Bucle WHILE
     | repeat_loop   // Bucle REPEAT ... UNTIL
     | if_stmt       // Condicional IF ... THEN ... [ELSE ...]
     | call_stmt     // Llamadas a procedimientos
     | expr_stmt     // Sentencias de expresi√≥n (por ejemplo accesos A[i])
     | return_stmt

// ---------------------------------------------------------------------------
// 3. Listas de sentencias (una sentencia por l√≠nea)
// ---------------------------------------------------------------------------
// Regla com√∫n dentro de "begin ... end" y de "repeat ... until":
//    SEP stmt (SEP stmt)* SEP?
// Se factoriza como una lista de "l√≠neas".

line: stmt? SEP      // Una l√≠nea puede contener una sentencia o estar vac√≠a, pero siempre termina en salto de l√≠nea
stmt_list: line+     // Secuencia de una o m√°s l√≠neas
// Sentencia de retorno (se ignora en el AST de complejidad)
return_stmt: RETURN expr?

// ---------------------------------------------------------------------------
// 4. Bloques
// ---------------------------------------------------------------------------

block: BEGIN stmt_list END   // Bloque cl√°sico "begin ... end"

// Bloque o sentencia √∫nica (para cuerpos de if/for/while)
block_or_list: block | stmt


// ---------------------------------------------------------------------------
// 5. Procedimientos de nivel superior
// ---------------------------------------------------------------------------
// Forma general: nombre(params) begin ... end

proc_def: NAME "(" param_list? ")" SEP? BEGIN stmt_list END

// Par√°metros formales: permiten cosas como a[1..n], A[1..n], x, etc.
param: NAME ("[" subscript_list "]")*     // Nombre con cero o m√°s √≠ndices/arreglos
param_list: param ("," param)*            // Lista de par√°metros separados por coma

// ---------------------------------------------------------------------------
// 6. Declaraciones
// ---------------------------------------------------------------------------

// Declaraci√≥n de objeto local:
//   Clase nombre_objeto
object_decl: NAME NAME

decl_stmt: object_decl                    // Por ahora la √∫nica forma de declaraci√≥n es la de objeto

// ---------------------------------------------------------------------------
// 7. Sentencia de expresi√≥n
// ---------------------------------------------------------------------------
// Permite expresiones sueltas como sentencia, por ejemplo accesos A[n]

expr_stmt: expr

// ---------------------------------------------------------------------------
// 8. Asignaciones y L-values (variables, √≠ndices y campos)
// ---------------------------------------------------------------------------

// Asignaci√≥n:
//    <lvalue> <- <expr>
// o  <lvalue> ü°® <expr>
assign: lvalue ASSIGN expr

// lvalue soporta:
//   - variable simple: x
//   - acceso a arreglos: A[i], A[i,j], A[1..n]
//   - campos de objetos: objeto.campo
//   - combinaciones: objeto.campo[i].otro_campo[j]
lvalue: NAME ("[" subscript_list "]")* ("." NAME ("[" subscript_list "]")* )*

// Soporte de slices y listas de sub√≠ndices, por ejemplo:
//    a[1..n], A[i, j+1, 3..k]
slice: expr (".." expr)?          // Expresi√≥n simple o rango expr .. expr
subscript_list: slice ("," slice)*

// ---------------------------------------------------------------------------
// 9. Bucles y condicionales
// ---------------------------------------------------------------------------

// Bucle FOR cl√°sico:
//
//   for i <- a to b do
//     begin
//       ...
//     end
//
// Opcionalmente se admite "step expr".
for_loop: FOR NAME ASSIGN expr TO expr (STEP expr)? DO SEP? block_or_list

// Bucle WHILE:
//
//   while (condicion) do
//     begin
//       ...
//     end
while_loop: WHILE "(" bool_expr ")" DO SEP? block_or_list

// Bucle REPEAT:
//
//   repeat
//     ...
//   until (condicion)
//
// No utiliza "begin/end"; el cuerpo es directamente una lista de sentencias.
repeat_loop: REPEAT stmt_list UNTIL "(" bool_expr ")"

// Condicional IF:
//
//   if (condicion) then
//     begin
//       ...
//     end
//   else
//     begin
//       ...
//     end
//
// Se permite que "else" vaya en la siguiente l√≠nea (SEP opcional antes de ELSE).
if_stmt: IF "(" bool_expr ")" THEN SEP? block_or_list (ELSE SEP? block_or_list)?

// ---------------------------------------------------------------------------
// 10. Llamadas a procedimientos/funciones como sentencia
// ---------------------------------------------------------------------------

call_stmt: CALL NAME "(" arg_list? ")"
arg_list: expr ("," expr)*       // Lista de argumentos separados por coma

// ---------------------------------------------------------------------------
// 11. Expresiones booleanas y relacionales
// ---------------------------------------------------------------------------

?bool_expr: or_expr

// OR de corto circuito: expr1 or expr2 or ...
?or_expr: and_expr (OR and_expr)*

// AND de corto circuito: expr1 and expr2 and ...
?and_expr: not_expr (AND not_expr)*

// Negaci√≥n l√≥gica y par√©ntesis
?not_expr: NOT not_expr          // "not expr"
         | rel_expr
         | "(" bool_expr ")"     // Agrupaci√≥n expl√≠cita

// Expresiones relacionales: expr < expr, expr = expr, etc.
// Si no hay operador relacional, simplemente se devuelve la expresi√≥n aritm√©tica.
?rel_expr: expr (rel_op expr)?
rel_op: EQ | NE | NE2 | LT | LE | GT | GE | LE_U | GE_U | NE_U

// ---------------------------------------------------------------------------
// 12. Expresiones aritm√©ticas
// ---------------------------------------------------------------------------
// Precedencia cl√°sica: unary  <  prod (*, /, div, mod)  <  sum (+, -)

?expr: sum

?sum: prod ((PLUS | MINUS) prod)*

?prod: unary ((MUL | REAL_DIV | DIV_INT | MOD) unary)*

// Operadores unarios, por ahora solo el signo negativo
?unary: MINUS unary    -> neg
      | atom

// ---------------------------------------------------------------------------
// 13. √Åtomos y llamadas a funciones en expresiones
// ---------------------------------------------------------------------------
//
// √Åtomos posibles:
//   - n√∫meros literales
//   - literales booleanos (T/F, true/false)
//   - null
//   - lvalues (variables, arreglos, campos)
//   - llamadas a funciones: nombre(expr, ...)
//   - operadores de techo/piso con brackets Unicode: ‚åàexpr‚åâ, ‚åäexpr‚åã
//   - expresiones entre par√©ntesis
?atom: NUMBER
     | T          -> true
     | TRUE       -> true
     | F          -> false
     | FALSE      -> false
     | NULL
     | lvalue
     | NAME "(" arg_list? ")"   -> func_call
     | CEIL_OPEN expr CEIL_CLOSE    -> ceil_brackets
     | FLOOR_OPEN expr FLOOR_CLOSE  -> floor_brackets
     | "(" expr ")"

// ---------------------------------------------------------------------------
// 14. Definiciones de clases (nivel superior)
// ---------------------------------------------------------------------------
//
// Sintaxis simplificada estilo:
//   Casa {Area color propietario}
//
// Donde "Casa" es el nombre de la clase y el bloque entre llaves
// es una lista de atributos (solo nombres).
class_def: NAME LBRACE attr_list? RBRACE
attr_list: NAME (NAME)*           // Atributo1 Atributo2 Atributo3 ...

// ---------------------------------------------------------------------------
// 15. Palabras clave (case-insensitive)
// ---------------------------------------------------------------------------
// Se definen como tokens con prioridad (.50 / .60) y expresiones regulares
// que ignoran may√∫sculas/min√∫sculas. Esto evita conflictos con NAME.

ASSIGN.50: "<-" | "ü°®"

FOR.50: /(?i:for)/
TO.50: /(?i:to)/
STEP.50: /(?i:step)/
DO.50: /(?i:do)/
WHILE.50: /(?i:while)/
REPEAT.50: /(?i:repeat)/
UNTIL.50: /(?i:until)/
IF.50: /(?i:if)/
THEN.50: /(?i:then)/
ELSE.50: /(?i:else)/
BEGIN.60: /(?i:begin)/
END.60: /(?i:end)/
CALL.50: /(?i:call)/
NULL.50: /(?i:null)/
AND.50: /(?i:and)/
OR.50: /(?i:or)/
NOT.50: /(?i:not)/

T.50: /(?i:T)(?![A-Za-z0-9_])/
F.50: /(?i:F)(?![A-Za-z0-9_])/

TRUE.50: /(?i:true)/
FALSE.50: /(?i:false)/
RETURN.50: /(?i:return)/

// ---------------------------------------------------------------------------
// 16. Operadores aritm√©ticos
// ---------------------------------------------------------------------------

PLUS: "+"
MINUS: "-"
MUL: "*"
REAL_DIV: "/"              // Divisi√≥n real
DIV_INT.50: /(?i:div)/     // Divisi√≥n entera
MOD.50: /(?i:mod)/         // Resto

// ---------------------------------------------------------------------------
// 17. Operadores especiales de techo/piso (Unicode)
// ---------------------------------------------------------------------------

CEIL_OPEN: "‚åà"
CEIL_CLOSE: "‚åâ"
FLOOR_OPEN: "‚åä"
FLOOR_CLOSE: "‚åã"

// ---------------------------------------------------------------------------
// 18. Operadores de comparaci√≥n
// ---------------------------------------------------------------------------
// Se ofrecen varias variantes, incluyendo s√≠mbolos Unicode.

EQ: "="
NE: "!="
NE2: "<>"
LE: "<="
LT: "<"
GE: ">="
GT: ">"
LE_U: "‚â§"
GE_U: "‚â•"
NE_U: "‚â†"

// ---------------------------------------------------------------------------
// 19. Tokens b√°sicos
// ---------------------------------------------------------------------------

LBRACE: "{"
RBRACE: "}"
NAME: /[a-zA-Z_][a-zA-Z0-9_]*/   // Identificadores
NUMBER: /[0-9]+/                 // N√∫meros enteros sin signo

// ---------------------------------------------------------------------------
// 20. Separadores, espacios y comentarios
// ---------------------------------------------------------------------------

// SEP = uno o m√°s saltos de l√≠nea; separa sentencias
SEP: /(\r?\n)+/

// Espacios en blanco en l√≠nea (tabs, espacios) se ignoran
%import common.WS_INLINE
%ignore WS_INLINE

// Comentarios de l√≠nea seg√∫n el enunciado:
//   ‚ñ∫ texto del comentario
// Todo lo que sigue a "‚ñ∫" hasta el final de l√≠nea se ignora.
COMMENT_ARROW: /‚ñ∫[^\n]*/
%ignore COMMENT_ARROW
