?start: program
program: (proc_def | stmt)*

?stmt: assign
     | for_loop
     | while_loop
     | repeat_loop
     | if_stmt
     | call_stmt
     // â¬…ï¸ OJO: no permitimos block ni proc_def como stmt

// ===== Bloques y listas =====
block: BEGIN stmt_list END
stmt_list: (stmt)*                // â¬…ï¸ (re)definida explÃ­citamente
block_or_list: block | stmt_list

// ===== Procedimientos (solo top-level) =====
proc_def: NAME "(" param_list? ")" BEGIN stmt_list END
param_list: NAME ("," NAME)*

// ===== Asignaciones y lvalues =====
assign: lvalue ASSIGN expr
lvalue: NAME ("[" subscript_list "]")* ("." NAME ("[" subscript_list "]")* )*
slice: expr (".." expr)?
subscript_list: slice ("," slice)*

// ===== Bucles y condicionales =====
for_loop: FOR NAME ASSIGN expr TO expr (STEP expr)? DO block_or_list END_FOR
while_loop: WHILE "(" bool_expr ")" DO block_or_list END_WHILE
repeat_loop: REPEAT block_or_list UNTIL "(" bool_expr ")"

if_stmt: IF "(" bool_expr ")" THEN block_or_list (ELSE block_or_list)? END_IF

// ===== Llamadas =====
call_stmt: CALL NAME "(" arg_list? ")"
arg_list: expr ("," expr)*

// ===== Booleanas =====
?bool_expr: or_expr
?or_expr: and_expr (OR and_expr)*
?and_expr: not_expr (AND not_expr)*
?not_expr: NOT not_expr
         | rel_expr
         | "(" bool_expr ")"

// ===== Relacionales =====
?rel_expr: expr (rel_op expr)?
rel_op: EQ | NE | NE2 | LT | LE | GT | GE | LE_U | GE_U | NE_U

// ===== AritmÃ©tica =====
?expr: sum
?sum: prod ((PLUS|MINUS) prod)*
?prod: unary ((MUL|REAL_DIV|DIV_INT|MOD) unary)*
?unary: MINUS unary -> neg
      | atom

?atom: NUMBER
     | T          -> true
     | F          -> false
     | NULL
     | lvalue
     | NAME "(" arg_list? ")"   -> func_call
     | CEIL_OPEN expr CEIL_CLOSE  -> ceil_brackets
     | FLOOR_OPEN expr FLOOR_CLOSE -> floor_brackets
     | "(" expr ")"

// ===== Palabras clave =====
ASSIGN.50: "<-" | "ðŸ¡¨"
FOR.50: "for"
TO.50: "to"
STEP.50: "step"
DO.50: "do"
END_FOR.100: "end-for"
WHILE.50: "while"
END_WHILE.100: "end-while"
REPEAT.50: "repeat"
UNTIL.50: "until"
IF.50: "if"
THEN.50: "then"
ELSE.50: "else"
END_IF.100: "end-if"
BEGIN.60: "begin"
END.60: "end"
CALL.50: "CALL"
NULL.50: "NULL"
AND.50: "and"
OR.50: "or"
NOT.50: "not"
T.50: "T"
F.50: "F"

// ===== Operadores =====
PLUS: "+"
MINUS: "-"
MUL: "*"
REAL_DIV: "/"
DIV_INT.50: "div"
MOD.50: "mod"

// ===== Techo/Piso (Unicode) =====
CEIL_OPEN: "âŒˆ"
CEIL_CLOSE: "âŒ‰"
FLOOR_OPEN: "âŒŠ"
FLOOR_CLOSE: "âŒ‹"

// ===== Comparadores =====
EQ: "="
NE: "!="
NE2: "<>"
LE: "<="
LT: "<"
GE: ">="
GT: ">"
LE_U: "â‰¤"
GE_U: "â‰¥"
NE_U: "â‰ "

// ===== Tokens base =====
NAME: /[a-zA-Z_][a-zA-Z0-9_]*/
NUMBER: /[0-9]+/

%import common.WS_INLINE
%import common.NEWLINE
%ignore WS_INLINE
%ignore NEWLINE

COMMENT_ARROW: /â–º[^\n]*/
%ignore COMMENT_ARROW
