// ============================================================================
// pseudocode.lark ‚Äî Gram√°tica del pseudoc√≥digo (estilo Pascal del enunciado)
// ============================================================================
//
// Caracter√≠sticas principales:
//
// - Cuerpos de FOR / WHILE / IF siempre usan:
//
//       begin
//         ...
//       end
//
//
// - Bucle REPEAT ... UNTIL (sin begin/end en el cuerpo).
//
// - Una sentencia por l√≠nea (SEP = salto de l√≠nea como separador).
//
// - Comentarios de l√≠nea con el car√°cter '‚ñ∫', que son ignorados:
//
//       ‚ñ∫ esto es un comentario
//
// - Asignaci√≥n con "<-" o "ü°®".
//
// - Soporte b√°sico para:
//     * Definici√≥n de clases a nivel superior (class_def).
//     * Declaraci√≥n de objetos dentro de bloques (Clase nombre_objeto).
//
// - Nivel toplevel restringido a:
//
//       class_def | proc_def | block
//
// ============================================================================


// ============================================================================
// 1. Inicio y unidad de compilaci√≥n
// ============================================================================

?start: program

// Programa completo: una o m√°s unidades toplevel
program: top_unit (SEP top_unit)* SEP?

// Unidad toplevel: clase, procedimiento o bloque global
top_unit: class_def | proc_def | block


// ============================================================================
// 2. Sentencias
// ============================================================================

// Sentencias b√°sicas admitidas dentro de un bloque
?stmt: assign
     | decl_stmt
     | for_loop
     | while_loop
     | repeat_loop
     | if_stmt
     | call_stmt
     | expr_stmt   // p.ej. A[n], A[10][m]


// ============================================================================
// 3. Listas de sentencias (una por l√≠nea)
// ============================================================================
//
// Dentro de begin ... end y repeat ... until, el enunciado asume
// una sentencia por l√≠nea. Para soportar comentarios y l√≠neas en blanco,
// se modela primero la "l√≠nea" y luego la lista de l√≠neas.
//
//   line: stmt? SEP
//   stmt_list: line+
//

// Una l√≠nea: opcionalmente una sentencia, seguida de un salto de l√≠nea
line: stmt? SEP

// Lista de l√≠neas dentro de un bloque / repeat
stmt_list: line+


// ============================================================================
// 4. Bloques
// ============================================================================

// Bloque cl√°sico BEGIN ... END que agrupa sentencias
block: BEGIN stmt_list END


// ============================================================================
// 5. Procedimientos (solo nivel superior)
// ============================================================================
//
// Forma general:
//
//   Nombre(params) begin
//     ...
//   end
//

proc_def: NAME "(" param_list? ")" BEGIN stmt_list END

// Par√°metro formal: permite arreglos anotados, p.ej. a[1..n], A[1..n], x, etc.
param: NAME ("[" subscript_list "]")*

// Lista de par√°metros separados por coma
param_list: param ("," param)*


// ============================================================================
// 6. Declaraciones
// ============================================================================
//
// Declaraci√≥n de objeto local dentro de un bloque:
//
//   Clase nombre_objeto
//

// Objeto local:   Clase nombre_objeto
object_decl: NAME NAME

// Sentencia de declaraci√≥n
decl_stmt: object_decl


// ============================================================================
// 7. Sentencias de expresi√≥n
// ============================================================================
//
// Se utilizan para expresiones "suelta" en una l√≠nea, como:
//
//   A[n]
//   A[10][m]
//
// que el enunciado usa a modo de ‚Äúdeclaraciones‚Äù de tama√±o de arreglo.
//

expr_stmt: expr


// ============================================================================
// 8. Asignaciones y L-values
// ============================================================================
//
// Forma general:
//
//   lvalue <- expr
//
// L-value admite variables simples, arreglos y campos encadenados.
//

assign: lvalue ASSIGN expr

// Variable, √≠ndices y acceso a campos:
//
//   NAME
//   NAME[...]
//   NAME[...].campo[...].otroCampo
//
lvalue: NAME ("[" subscript_list "]")*
          ("." NAME ("[" subscript_list "]")* )*

// Slice de √≠ndices: expr o expr..expr
slice: expr (".." expr)?

// Lista de √≠ndices/slices separados por coma
subscript_list: slice ("," slice)*


// ============================================================================
// 9. Bucles y condicionales
// ============================================================================

// for i <- a to b [step s] do begin ... end
for_loop: FOR NAME ASSIGN expr TO expr (STEP expr)? DO block

// while (condicion) do begin ... end
while_loop: WHILE "(" bool_expr ")" DO block

// repeat ... until (condicion)   (SIN begin/end en el cuerpo)
repeat_loop: REPEAT stmt_list UNTIL "(" bool_expr ")"

// if (cond) then begin ... end [else begin ... end]
//
// Se permite que el ELSE vaya en la l√≠nea siguiente, gracias al SEP? opcional.
//
if_stmt: IF "(" bool_expr ")" THEN block (SEP? ELSE block)?


// ============================================================================
// 10. Llamadas a procedimientos/funciones
// ============================================================================

// Llamada como sentencia: CALL f(...)
call_stmt: CALL NAME "(" arg_list? ")"

// Lista de argumentos separados por coma
arg_list: expr ("," expr)*


// ============================================================================
// 11. Expresiones booleanas y relacionales
// ============================================================================

?bool_expr: or_expr

?or_expr: and_expr (OR and_expr)*

?and_expr: not_expr (AND not_expr)*

?not_expr: NOT not_expr
         | rel_expr
         | "(" bool_expr ")"

// Expresi√≥n relacional opcionalmente con operador
?rel_expr: expr (rel_op expr)?

// Operadores relacionales disponibles
rel_op: EQ | NE | NE2 | LT | LE | GT | GE | LE_U | GE_U | NE_U


// ============================================================================
// 12. Expresiones aritm√©ticas
// ============================================================================
//
// Precedencias:
//
//   unary (-) > prod (*, /, div, mod) > sum (+, -)
//

?expr: sum

?sum:  prod ((PLUS | MINUS) prod)*

?prod: unary ((MUL | REAL_DIV | DIV_INT | MOD) unary)*

// Negativo unario y √°tomos
?unary: MINUS unary    -> neg
      | atom


// ============================================================================
// 13. √Åtomos y llamadas a funci√≥n
// ============================================================================
//
// Incluye:
//
//   - Literales num√©ricos y booleanos.
//   - NULL.
//   - L-values (variables, arreglos, campos).
//   - Llamadas a funci√≥n f(...) en contexto de expresi√≥n.
//   - Techo/piso con s√≠mbolos Unicode.
//   - Par√©ntesis (expr).
//

?atom: NUMBER
     | T          -> true
     | TRUE       -> true
     | F          -> false
     | FALSE      -> false
     | NULL
     | lvalue
     | NAME "(" arg_list? ")"   -> func_call
     | CEIL_OPEN  expr CEIL_CLOSE   -> ceil_brackets
     | FLOOR_OPEN expr FLOOR_CLOSE  -> floor_brackets
     | "(" expr ")"


// ============================================================================
// 14. Clases (top-level)
// ============================================================================
//
// Forma general:
//
//   Casa {Area color propietario}
//

class_def: NAME LBRACE attr_list? RBRACE

// Lista de atributos de la clase, p.ej. "Area color propietario"
attr_list: NAME (NAME)*


// ============================================================================
// 15. Palabras clave (case-insensitive)
// ============================================================================
//
// Los sufijos `.50` / `.60` son prioridades de terminal en Lark.
// Se usan para resolver conflictos entre KEYWORDS y NAME.
//

ASSIGN.50: "<-" | "ü°®"

FOR.50:    /(?i:for)/
TO.50:     /(?i:to)/
STEP.50:   /(?i:step)/
DO.50:     /(?i:do)/
WHILE.50:  /(?i:while)/
REPEAT.50: /(?i:repeat)/
UNTIL.50:  /(?i:until)/

IF.50:     /(?i:if)/
THEN.50:   /(?i:then)/
ELSE.50:   /(?i:else)/

BEGIN.60:  /(?i:begin)/
END.60:    /(?i:end)/

CALL.50:   /(?i:call)/

NULL.50:   /(?i:null)/

AND.50:    /(?i:and)/
OR.50:     /(?i:or)/
NOT.50:    /(?i:not)/

// Constantes booleanas en may√∫scula (T/F).
// En min√∫scula se tokenizan como NAME.
T.50: "T"
F.50: "F"

TRUE.50:  /(?i:true)/
FALSE.50: /(?i:false)/


// ============================================================================
// 16. Operadores aritm√©ticos
// ============================================================================

PLUS:      "+"
MINUS:     "-"
MUL:       "*"
REAL_DIV:  "/"
DIV_INT.50: /(?i:div)/
MOD.50:     /(?i:mod)/


// ============================================================================
// 17. Operadores especiales techo/piso (Unicode)
// ============================================================================

CEIL_OPEN:  "‚åà"
CEIL_CLOSE: "‚åâ"
FLOOR_OPEN: "‚åä"
FLOOR_CLOSE:"‚åã"


// ============================================================================
// 18. Comparadores
// ============================================================================

EQ:   "="
NE:   "!="
NE2:  "<>"
LE:   "<="
LT:   "<"
GE:   ">="
GT:   ">"
LE_U: "‚â§"
GE_U: "‚â•"
NE_U: "‚â†"


// ============================================================================
// 19. Tokens base
// ============================================================================

LBRACE: "{"
RBRACE: "}"

NAME:   /[a-zA-Z_][a-zA-Z0-9_]*/
NUMBER: /[0-9]+/


// ============================================================================
// 20. Separadores, espacios y comentarios
// ============================================================================
//
// SEP: uno o m√°s saltos de l√≠nea (separador de sentencias).
// WS_INLINE: espacios/tabs en la misma l√≠nea, ignorados.
// COMMENT_ARROW: comentario de l√≠nea iniciado por '‚ñ∫', hasta el fin de l√≠nea.
//

// SEP = uno o m√°s saltos de l√≠nea (separador de sentencias)
SEP: /(\r?\n)+/

%import common.WS_INLINE
%ignore WS_INLINE

// Comentarios de l√≠nea con '‚ñ∫'
COMMENT_ARROW: /‚ñ∫[^\n]*/
%ignore COMMENT_ARROW
